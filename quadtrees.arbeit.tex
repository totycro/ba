\documentclass[%
			%fontsize=12pt,%
			paper=a4,% 
			%DIV10, % mehr text pro seite als defaultyyp
			DIV11,
			%DIV=calc,%
			%twoside=false,%
			liststotoc,
			bibtotoc,
			draft=false,% final|draft % draft ist platzsparender (kein code, bilder..)
			titlepage
			]{scrartcl}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

% for color-highlighted code
\usepackage[usenames]{color} % for grey comments
%\usepackage{alltt}

\usepackage[doublespacing]{setspace}
\usepackage{tabularx}
\usepackage{comment}
\usepackage[final]{listings} % sourcecode in document
\usepackage{url}      % for urls
\usepackage{multicol}
\usepackage{caption}
\usepackage{enumerate}

\usepackage{graphicx}

%\usepackage[square]{natbib} % \cite ; square|round etc.
\usepackage[numbers,square]{natbib}
%\usepackage[square, authoryear]{natbib}

%\usepackage{bibgerm}
%\bibliographystyle{plain}
%\bibliographystyle{alpha}
\bibliographystyle{alphadin}
%\bibliographystyle{dinat}
%\bibliographystyle{chicago}
%\bibliographystyle{plainnat}

%\bibdata{bib.bib}

\newcommand{\zit}[3]{#1 \cite{#2}, #3}
\newcommand{\zitx}[2]{#1 \cite{#2}}
\newcommand{\footzit}[3]{\footnote{\zit{#1}{#2}{#3}}}
\newcommand{\footzitx}[2]{\footnote{\zitx{#1}{#2}}}

\newcommand{\footurl}[2]{\footnote{\url{#1}, abgerufen am #2}}

\newcommand{\inlinecode}[1]{\mbox{\texttt{#1}}}

\newcommand{\mynull}{\textit{NULL}}
%\newcommand{\mynull}{\textbf{nil}}

\newcommand{\kd}{\mbox{\textit{k}-d}}

% smaller url style
\makeatletter
\def\url@leostyle{%
\@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother
\urlstyle{leo}

\newcommand{\myfig}[5] {
 \begin{figure}[tbph]
	 \centering
	 \includegraphics[#3]{#1}
	 \caption[#4]{#5}
	 \label{fig:#2}
 \end{figure}
}

\title{Quadtrees}
\author{Bernhard Mallinger \\ e0707663 \\ TU Wien}
%\subtitle{}
%\date{13. November 2007}
\publishers{Betreut durch Univ.-Ass. Dipl.-Ing., BSc Christian Schauer}

%\usepackage{fancyhdr}
%\setlength{\headrulewidth}{0.0pt}
\pagestyle{plain}

\definecolor{grey}{gray}{.35} % for grey commnts
\lstset{language=Python,%
escapeinside={@}{@},
extendedchars=false,%
%inputencoding=utf8x,%
basicstyle=\ttfamily\small,%
commentstyle=\color{grey},%
%keywordstyle=,% no bold tt in standard font
%captionpos=b,
tabsize=2,
showstringspaces=false,
breaklines=true,
breakindent=0pt
}

% just for screen-display!
%\usepackage{newcent}

\begin{document}

\maketitle

\tableofcontents 

\newpage

%%%%
% TODO
%
% Einleitung mit erklärung:
% k
% n
% schlüssel
% mehrdimensionale daten (bisschen wie kdtree.pdf)
%
% schlüssel unique -- überlauflisten
%
% binäre suche im anfang reinbringen -- bin tree
%
% point qt: suche: neighborhood 
%
% anwendungen (vllt extrakapitel) (kriterien für anwendbarkeit)
%
% seite 3 (aus paper zitieren)
%
% bild pr tree 
%
% kurz erweiterung auf mehrere dimensionen am bsp von octtree besprechen
%
% pr quadtree vllt noch mehr literatur finden


\part{Theorie}
\section{Einführung}
Quadtrees stellen eine Datenstruktur dar, welche von Binärbäumen abgeleitet sind. Sie erweitern dessen Prinzip der rekursiven, hierarchischen Aufteilung eines Raumes auf mehrere Dimensionen. 
Im Allgemeinen beschränkt man sich hier zur Vereinfachung auf zweidimensionale Daten, wobei die Verallgemeinerung auf \textit{k}-dimensionale Daten trivial ist.\footzit{Vgl}{DBLP:journals/acta/FinkelB74}{Seite 9}

Anstatt wie bei Binärbäumen den Raum in jedem Schritt in zwei Unterbäume zu teilen, werden bei Quadtrees vier Kinder verwendet, um alle möglichen Richtungen in zwei Dimensionen bezüglich des aktuellen Knoten abzudecken. Der Name "`Quadtree"' leitet sich hiervon ab (lat. "`quadri-"': "`vier-"'). 
Analog dazu bezeichnet man 3-dimensionale Bäume als "`Octtrees"'. Es ist weiters einfach zu sehen, dass $k$-dimensionale Bäume $2^k$ Kinder pro Knoten aufweisen.\footzit{Vgl.}{Bentley:1979}{Seite 16}

Räumliche Strukturen wie Quadtrees sind generell dann sinnvoll, wenn die Entfernung zweier Punkte für die Anwendung relevant ist.
Beispiele hierfür sind unter anderem Repräsentation von Bildern (angrenzende Bereiche besitzen oftmals ähnliche Farben), Kollisionserkennung, wo das Interesse auf sich überschneidenden Strukturen liegt, oder Bereichsabfragen in Datenbanken.

Beim Zugriff auf die so in einem Quadtree gespeicherten Daten unterscheidet man zwischen verschiedenen Anfragetypen:\footnote{Basierend auf \cite{Knuth:1998:ACP:280635}, Seite 559 und der Erweiterung durch \cite{Bentley:1975:nearest}}
\begin{description}
	\item[Point Query.]
		Mit dieser Anfrage versucht man herauszufinden, welche Daten sich bei einem bestimmten Punkt befinden.
		Antworten auf diese Anfrage können entweder \mynull\ bzw.\ ein Datenobjekt sein.
	\item[Range Query.]
		Hier interessiert man sich für die Knoten, welche innerhalb von Bereichen, die hinsichtlich mehreren Dimensionen ausgedehnt sein können, liegen.
		Zurückgegeben wird eine möglicherweise leere Liste von Datenobjekten.
	\item[Neighborhood Query.]
		Dieser Anfragetyp fokussiert sich auf Nähebeziehungen.
		Konkret werden die Knoten gesucht, welche die geringste Entfernung zu einem bestimmten Knoten aufweisen oder sich innerhalb eines gewissen Radius davon befinden.
		Der Rückgabewert kann hier eine Liste oder ein einzelnes Datenobjekt sein.
\end{description}


\subsection{Funktionsprinzip}

Wie eingangs erwähnt, wird bei einem Quadtree der Raum in jedem Schritt in zwei Dimensionen geteilt.
In diesem Kontext bezeichnet man die Abschnitte der Unterteilung als "`Quadranten"'.
Dies kann, wie Abbildung \ref{fig:quadtree} auf Seite \pageref{fig:quadtree} demonstriert, direkt an den Koordinaten der Knoten stattfinden, je nach Quadtreetyp werden hier jedoch verschiedene Strategien eingesetzt.

Die einzelnen Knoten eines Baumes beinhalten Verweise auf vier Kindstrukturen, welche diejenigen Daten beinhalten, die sich vollständig in der entsprechenden Richtung des Knotens befinden. 
Die Koordinaten der zu speichernden Daten bestimmen demnach die Gestalt der Struktur.
Die eigentlichen Daten werden je nach Quadtreetyp in allen Knoten oder nur den Blättern gespeichert.

Dieses Prinzip der rekursiven, hierarchischen Dekomposition erlaubt das effiziente Suchen in logarithmischer Zeit, sofern eine adäquate Balancierung sichergestellt ist.\footnote{Siehe Kapitel \ref{sec:pointquadtree-suche} auf Seite \pageref{sec:pointquadtree-suche}}
\myfig{img/quadtree}{quadtree}{width=.4\textwidth}{Funktionsprinzip eines Quadtrees}{Alle Kinder eines Knotens repräsentieren Teilbäume, welche sich vollständig in NW-, NE-, \mbox{SW-} oder SE-Richtung des aktuellen Knoten befinden. Je nach Konvention können die Quadranten auch mittels ihrer Nummerierung referenziert werden.}

\section{Punktbasierte Quadtrees}
\label{sec:pointbased}
\subsection{Point Quadtree}
Dieser Quadtreetyp wurde erstmals 1974 von Finkel und Bentley in \cite{DBLP:journals/acta/FinkelB74} eingeführt und stellt die Basis vieler weiterer Entwicklungen dar.\footzit{Vgl.}{compgeom:2000}{Seite 318}
Point Quadtrees kann man als direkte Verallgemeinerung von binären Suchbäumen auf mehrdimensionale Räume auffassen.\footzit{Vgl.}{Samet90}{Seite 48}
Ähnlich zu diesen erfolgt die Aufteilung direkt an den Koordinaten der Knoten, sowie an beiden Dimensionen gleichzeitig. 

% vllt deBerg S 316 tiefe O( (d+1) n )
% und S 322
% As we have seen in this chapter, the size and depth of a quadtree for a set of n points cannot be bounded in terms of the number of the number of points only.

Abbildung \ref{fig:pointquadtree} auf Seite \pageref{fig:pointquadtree} zeigt eine Instanz eines Point Quadtrees in zwei üblichen Darstellungsvarianten: Baum- und Graphenform.
In der Ersteren wird nur die Struktur des Baumes betrachtet, die Lage der Datenknoten ist ausschließlich relativ zueinander sichtbar.
Die Zweitere konzentriert sich mehr auf die absolute Position der Punkte in einem Koordinatensystem und zeigt zusätzlich dazu die rekursive Dekompositionsstruktur ein.
Die Bezeichnung der Knoten in der Grafik gibt hier die Reihenfolge des Einfügens an. Bereits hier wird deutlich, dass die Form des Baumes durch diese Reihenfolge determiniert wird.\footnote{Vgl. Kapitel \ref{sec:pointquadtree:insert} auf Seite \pageref{sec:pointquadtree:insert}}
\myfig{img/pointquadtree-ins7+tree-trimmed}{pointquadtree}{width=.9\textwidth}{Point Quadtree}{Gegenüberstellung: Ein Point Quadtree in Baum- bzw.\ Graphendarstellung}

\subsubsection{Suche}
\label{sec:pointquadtree-suche}
Der Algorithmus zur Suche von Koordinaten (Point Query) ergibt sich unmittelbar aus dem rekursiven Aufbauprinzip des Quadtrees. 

Die Suche beginnt beginnt an der Wurzel. In jedem Schritt werden je ein Vergleich der $x$- und $y$-Koordinate des aktuellen Knotens mit dem gesuchten Knoten durchgeführt, wodurch der Quadrant bestimmt wird, in welchen sich der gesuchte Knoten befindet. Ist dieser Quadrant leer, d.h.\ ist kein Kindknoten bezüglich dieser Richtung am aktuellen Knoten vorhanden, wird die Suche erfolglos abgebrochen; andernfalls wird sie bei dem Kindknoten, welcher diesen Quadranten abdeckt, rekursiv fortgesetzt, bis die Koordinaten des gesuchten Knoten mit jenen des aktuellen Knoten übereinstimmen.

Durch die rekursive Aufteilung kann hier im Average Case mit einer  Gesamtpfadlänge\footnote{engl. TPL: Total path length} von $N \log_4 N$ gerechnet werden, was in empirischen Untersuchungen mit Einfügungen in zufälliger Reihenfolge bestätigt wurde.\footzit{Vgl.}{DBLP:journals/acta/FinkelB74}{Seite 4}
Dies führt in der Folge bei der Suche nach einzelnen Punkten zu einer Laufzeit von $O(\log_4 N)$.
Allerdings hängt diese Größe von der Balancierung des Baumes ab, wofür es beim Point Quadtree keine Garantien gibt,\footnote{Vgl. Kapitel \ref{sec:pointquadtree:insert} auf Seite \pageref{sec:pointquadtree:insert}}
was im Falle einer Entartung (Worst Case) zu einer linearen Laufzeit ($O(n)$) führt.\footzit{Vgl.}{Samet90}{Seite 52}

Die Bereichssuche gestaltet sich ähnlich der Punktabfrage.
Der essentielle Unterschied besteht darin, dass hier die Suche möglicherweise in mehreren Quadranten eines Knotens fortgesetzt werden muss.
Die zu durchsuchenden Quadranten werden bestimmt, indem überprüft wird, ob der Bereich dieses Quadranten mit dem gesuchten Bereich überlappt.
Weiters wird für jeden Knoten, welcher besucht wird, festgestellt, ob dieser sich in dem spezifizierten Bereich befindet; dieser wird gegebenenfalls zurückgegeben.\footzit{Vgl.}{DBLP:journals/acta/FinkelB74}{Seite 5f}
In dieser Formulierung wird ebenso sofort deutlich, dass die gesuchte Region nicht unbedingt ein Rechteck bilden muss.

%Weiters kann gezeigt werden, dass Range Queries in $O(n\ log_k\ n)$ abgearbeitet werden können.\footzit{Vgl.}{Lueker78}{Seite 1}

\subsubsection{Einfügen}
\label{sec:pointquadtree:insert}
Das Verfahren zum Einfügen neuer Daten baut direkt auf die Suche auf.
In dem Quadranten, in welchem eine normale Suche abbrechen würde, wird das Datum eingefügt, indem an der entsprechenden Stelle, die sich offensichtlicher Weise in diesem Quadranten befinden muss, der Datenknoten platziert wird.
Konkret geschieht dies durch Setzen des diesem Quadranten zugeordneten Zeigers im Elternknoten.
Der asymptotische Aufwand dieser Operation ist natürlich identisch mit jenem der Suche.

Der neu eingefügte Knoten teilt den Raum wiederum an seinen $x$- bzw. $y$-Koordinaten und erweitert so die Struktur des Baumes.  
Es ist schnell ersichtlich, dass hier, genau wie bei einem Binärbaum, Entartungen auftreten können, da sich die Struktur dynamisch mit jedem eingefügten Element herausbildet.

Ein besonders Problem stellen hier etwa geordnete Daten da. Werden diese in der gegebenen Reihenfolge eingefügt, degeneriert der Baum zu einer linearen Liste, wodurch ein linearer Such- und somit gleichzeitig auch Einfügeaufwand entsteht, wie Abbildung \ref{fig:entartung} auf Seite \pageref{fig:entartung} demonstriert.
\myfig{img/pointquadtree-entartet-trimmed}{entartung}{width=.6\textwidth}{Entarteter Point Quadtree}{Ein Entarteter Point Quadtree}

Sind andererseits beim Aufbau des Baumes bereits alle Daten verfügbar, kann durch folgende Strategie ein optimale Balancierung erreicht werden: Der Median der sortierten Liste von Daten wird als Wurzel verwendet, die restlichen Elemente werden in 4 Gruppen eingeteilt, welche den Quadranten dieser Wurzel zugeordnet werden.
Auf jede dieser Unterteilungen wird der Prozess rekursiv angewendet. Dadurch kann erreicht werden, dass für jeden Knoten kein Kind mehr als die Hälfte aller Subknoten von diesem enthält, was empirisch zu 15\% geringeren Gesamtpfadlängen führt.\footzit{Vgl.}{DBLP:journals/acta/FinkelB74}{Seite 8f}


\subsubsection{Löschen}
\label{sec:pointquadtree:delete}
Das Entfernen eines Knotens aus einem Quadtree ist im Allgemeinen eine komplexe Operation, da die Knoten alleine die Struktur des Baumes bilden, und diese auch nach dem Löschen weiterhin gewisse Eigenschaften innehaben muss.
Daher ist es notwendig, eventuelle Kinder eines entfernten Knoten gemäß dem Baumaufbau neu zu platzieren.\footzit{Vgl.}{DBLP:journals/acta/FinkelB74}{Seite 8}
Bei Binärbäumen stellt dies kein allzu großes Problem dar, da in einem eindimensionalen Raum immer ein geeigneter Ersatz in Form des nächsten Knotens für einen zu entfernenden Knoten zur Verfügung steht.\footzit{Vgl.}{DBLP:journals/cacm/Samet80a}{Seite 2}
Im Fall von Quadtrees muss eine Substitution hingegen Bedingungen hinsichtlich zweier Dimensionen genügen, wodurch es ein Näheverhältnis wie im eindimensionalen Fall nicht gibt.\footzit{Vgl.}{DBLP:journals/cacm/Samet80a}{Seite 2}
Hier ist ein Ersatz nur dann möglich, wenn ein Blattknoten existiert, für den sich im Bereich zwischen den Achsen, welche durch die Koordinaten des Blattknoten bzw.\ deren des zu entfernenden Knoten verlaufen, kein anderer Knoten befindet.\footzit{Vgl.}{DBLP:journals/cacm/Samet80a}{Seite 3}

Ursprünglich wurde vorgeschlagen, alle Kinder des zu entfernenden Knoten neu einzufügen, was einen sehr aufwändigen Prozess darstellen kann.\footzit{Vgl.}{DBLP:journals/acta/FinkelB74}{Seite 8}
Sollte kein Knoten das oben genannte Kriterium erfüllen, kann nur durch günstige Wahl des Ersatzknotens die Anzahl der neu einzufügenden Knoten minimiert werden, wie etwa in \cite{DBLP:journals/cacm/Samet80a} gezeigt wird.

Eine weitere Optimierung kann dadurch erreicht werden, dass gelöschte Knoten nicht aus dem Baum entfernt, sondern nur als gelöscht markiert werden, um so die Struktur zu erhalten.
Die markierten Knoten dürfen bei zukünftigen Suchen nicht mehr zurückgegeben werden.
Nach jeder Entfernung erhöht sich hierdurch der Anteil der "`toten"' Knoten, was sich negativ auf die Performance aller Operationen auswirkt, und periodische Restrukturierungsmaßnahmen des Baumes erfordert.
Durch dieses Verfahren kann folglich der Aufwand einzelner Löschoperationen abgefedert werden, auf Kosten von regelmäßigen Wartungskosten.

\subsection{Pseudo Quadtree}
\label{sec:pseudoquadtree}
Der Pseudo Quadtree ist eine Abwandlung des Point Quadtrees, welche Löschen in logarithmischer Zeit sowie einfachere Rebalancierung bei Deformation ermöglicht. Diese Form des Quadtrees wurde 1982 von Overmars und van Leeuwen in \cite{DBLP:journals/acta/OvermarsL82} entwickelt.

Dem Pseudo Quadtree liegt die Analyse zu Grunde, dass die Probleme beim Entfernen von Knoten und bei der Balancierung bei Point Quadtrees daher stammen, dass die Datenpunkte selbst die Struktur des Baumes bilden, und so nur äußerst wenig Flexibilität vorhanden ist.\footzit{Vgl.}{DBLP:journals/acta/OvermarsL82}{Seite 6}
Aus diesem Grund wurde unterscheidet sich der Pseudo Quadtree davon insofern, als dass die Dekomposition des Raum an beliebigen Punkten stattfinden kann. 

Konkret funktioniert das Einfügen beim Pseudo Quadtree wie folgt:
Der Quadrant eines Datenpunktes wird gesucht.
Ist dieser leer, wird der Knoten hier eingefügt, ohne den Raum an dessen Koordinaten weiter zu unterteilen.
Befindet sich hier hingegen bereits ein anderer Knoten, muss eine neue Untergliederung eingeführt werden.
Hier können beliebige Strategien verwendet werden, um einen Teilungspunkt zu bestimmen, wodurch ein der Anwendung angepasster, gut balancierter Baum entstehen kann.
Als einzige Postcondition dieser Strategie muss garantiert werden,
dass die Knoten in verschiedene Quadranten eingeteilt werden.\footzit{Vgl.}{DBLP:journals/acta/OvermarsL82}{Seite 6}

Abbildung \ref{fig:pseudoquadtree} auf Seite \pageref{fig:pseudoquadtree} zeigt einen Pseudo Quadtree, welcher dieselben Daten wie der Point Quadtree in Abbildung \ref{fig:pointquadtree} auf Seite \pageref{fig:pointquadtree} beinhaltet.
In diesem Fall wurde der Mittelpunkt von zwei Knoten als Punkt zur Teilung verwendet.
\myfig{img/pseudoquadtree-ins3-trimmed}{pseudoquadtree}{width=.6\textwidth}{Pseudo Quadtree}{Pseudo Quadtree}

Sollte trotz einer angepassten Strategie ein Ungleichgewicht entstehen, kann der Subbaum, dessen Wurzel der höchste Knoten ist, bei welchem eine unbalancierte Verteilung seiner Kindknoten festgestellt wird, neu strukturiert werden, indem eine neue Aufteilung der vorhandenen Knoten berechnet wird.\footzit{Vgl.}{DBLP:journals/acta/OvermarsL82}{Seite 4f} % cp
Es kann gezeigt werden, dass im allgemeinen Fall eine Teilung möglich ist, in der sich in jedem der 4 Quadranten höchstens ein Drittel der Knoten befinden.\footzit{Vgl.}{DBLP:journals/acta/OvermarsL82}{Seite 7} % cp
Mit dieser Methode kann weiters garantiert werden, dass ein Pseudo Quadtree aufgebaut werden kann, dessen Höhe garantiert $\lceil \log_{d+1} n\rceil$ nicht überschreitet, wobei $n$ die Anzahl der Daten darstellt.\footzit{Vgl.}{DBLP:journals/acta/OvermarsL82}{Seite 8}

Durch diese Aufteilung des Raumes an beliebigen Punkten befinden sich Daten schließlich nur noch an den Blättern. Dies wiederum ist der optimale Fall bezüglich dem Entfernen von Knoten -- ein Knoten ohne Kinder kann jederzeit ohne zusätzlichen Aufwand gelöscht werden. Da das Entfernen eines Knotens immer auch das Suchen desselben erfordert, entsteht somit ein logarithmischer Aufwand.

%\ref{sec:pointquadtree:delete} \pageref{sec:pointquadtree:delete}

\subsection{\kd\ Tree}
Diese Variante wurde von Bentley kurz nach dem Point Quadtree 1974 in \cite{Bentley:1975} entwickelt. Der Name \kd\ deutet an, dass dieser Baum $k$-dimensionale Schlüssel verwendet. 

Der \kd\ Tree kann wie der Point Quadtree als Verallgemeinerung des Binärbaums gesehen werden, hier wird hingegen ein etwas anderer Ansatz verfolgt:
Anstatt den Raum gleichzeitig in allen Dimensionen zu partitionieren und somit $2^k$ Kinder pro Knoten zu erfordern, wird in jedem Schritt nur eine Dimension berücksichtigt und so eine binäre Unterteilung von eigentlich mehrdimensionalen Schlüsseln ermöglicht.
Diese Mehrdimensionalität wird bei \kd\ Trees weiters dadurch ausgedrückt, dass die Dimensionen, bezüglich derer an einer gewissen Tiefe geteilt wird, beliebig alternieren.
Im zweidimensionalen Fall könnte hier etwa bei geraden Tiefenebenen an der $x$-Achse bzw bei ungeraden an der $y$-Achse geteilt werden, wie etwa Abbildung \ref{fig:kdtree} auf Seite \pageref{fig:kdtree} zeigt.
Ursprünglich wurde genau dieses Abwechslungsmuster vorgeschlagen,\footzit{Vgl.}{Bentley:1975}{Seite 2}
wobei dieses auch dynamisch beliebig gewählt und so an die Daten angepasst werden kann\footzit{Vgl.}{Samet90}{Seite 66}.
Verwendet man hier einen dynamischen Ansatz, muss jedoch bei jedem Knoten der Diskriminator mitgespeichert werden.

\myfig{img/kdtree-tree-full-trimmed}{kdtree}{width=.78\textwidth}{\kd\ Tree}{Ein \kd\ Tree: Die Beschriftung links der Unterteilungen gibt die Achse an, bezüglich welcher die Knoten aufgeteilt werden.
\\ \\
Bezüglich den vorhergegangenen Abbildung wurden hier die Koordinaten der Knoten leicht verändert, da in diesem Fall ein äußerst schlecht balancierter \kd\ Tree entstehen würde, was der Autor aus Demonstrationszwecken vermeiden möchte.}

Dieser Typ bietet gegenüber einem Point Quadtree Vorteile bezüglich des Platzbedarfs:
anstatt $2^k$ sind hier nur 2 Kinder pro Knoten erforderlich.
Dies löst das Problem von vielen unnötigen Leereinträgen, welche bei einem Point Quadtree bei einer großen Dimensionsanzahl auftreten können.

Weiters müssen bei einem Point Quadtree bei einer Suche in jedem Schritt alle Dimensionen verglichen werden.
Bei einer großen Anzahl von Dimensionen kann dies überflüssig sein, wenn sich etwa Datensätze bereits durch eine echte Teilmenge ihrer Schlüssel einteilen lassen.
In diesem Fall reicht das Überprüfen dieser Teilmenge,
was in einem Point Quadtree nicht realisierbar ist, sich mit dem \kd\ Tree jedoch effizient verwirklichen lässt.\footzit{Vgl}{Samet90}{Seite 66}

Die Operationen Suche und Einfügen ergeben sich direkt aus dem Funktionsprinzip des \kd\ Trees, beide benötigen offensichtlich eine logarithmische Laufzeit im Average Case\footzit{Vgl.}{Bentley:1975}{Seite 1} (sofern der Baum nicht entartet).
Schwieriger ist hingegen das Löschen:
Nach dem Entfernen eines Knotens darf die Struktur des \kd\ Trees nicht verletzt werden, weshalb ein geeigneter Ersatz gefunden werden muss.
Für dieses Problem wurde eine Strategie entwickelt, welche auf der Lösung des analogen Problems bei Binärbäumen basiert und zugleich die Mehrdimensionalität im \kd\ Tree berücksichtigt.
Der wesentliche Aspekt dieses Verfahrens ist, dass der Ersatzknoten nicht wie beim Binärbaum immer ein Blatt ist, sondern im Allgemeinen auch Kinder hat, wodurch der Ersatzknoten auch substituiert werden muss.\footzit{Für eine detaillierte Beschreibung dieses Verfahrens siehe}{Bentley:1975}{Seite 7} 
Anstatt im Worst Case (bei Löschung der Wurzel) $n$ Neueinfügungen mit dem naiven Ansatz benötigt diese Methode nur $O(\log n)$ (bei einer Knotenanzahl von $n$).

Um diesem Problem gänzlich zu entgehen kann ähnlich dem Pseudo Quadtree\footnote{Siehe Kapitel \ref{sec:pseudoquadtree}} auch ein Pseudo \kd\ Tree\footzit{Vgl.}{DBLP:journals/acta/OvermarsL82}{Seite 13ff} verwendet werden,
in welchem analog zum Pseudo Quadtree die Unterteilung des Raumes nicht an den Koordinaten der Knoten, sondern an beliebigen Punkten vorgenommen wird, und so Daten nur in Blättern gespeichert werden.


% nicht paralellisiert suchen (quelle?)

\section{Bereichsbasierte Quadtrees}
%\subsection{Region Quadtree}

Wie im Kapitel \ref{sec:pointbased} ausführlich erläutert wurde, erfolgt die räumliche Dekomposition bei punktbasierten Quadtrees immer anhand der gegebenen Punkte.\footnote{Bei Point bzw.\ \kd\ Trees gilt dies direkt; bei Pseudo Quadtrees hingegen besteht die Abhängigkeit vielmehr indirekt: die Aufteilung stellt eine Funktion der Punkte dar.}
Dieses Kapitel beschäftigt sich mit Quadtrees, deren Form vordergründig a priori durch die Struktur des Raumes determiniert wird, was in etwa mit dem Prinzip von Tries vergleichbar ist.\footzit{Vgl.}{Samet90}{Seite 85}

Weiters wird in diesem Abschnitt nur insofern auf die verschiedenen Operationen eingegangen, als sie sich von punktbasierten Quadtrees unterscheiden.

\subsection{MX Quadtree}
Der MX Quadtree zeichnet durch seine Art der Raumunterteilung aus:
Der Bereich, in dem die Datenpunkte liegen, wird unabhängig von den konkreten Daten unterteilt,
und zwar rekursiv in vier gleichgroße Quadranten, 
bis auf der untersten Ebene 1x1 große Felder erreicht werden, welche die Daten beinhalten.\footzit{Vgl.}{Samet:1985:SCP:282957.282966}{Seite 1f}

Diese Art der Dekomposition setzt folgendes voraus:
\renewcommand{\labelenumi}{({\theenumi})}
\begin{enumerate}
	\item \textbf{Konstanter Bereich.}
		Die Region, in welcher sich Daten befinden, muss a priori bekannt sein und während des gesamten Programmablaufs konstant bleiben.
	\item \textbf{Diskrete Koordinaten.}
		Die Schlüssel dürfen nur diskrete Werte annehmen, ähnlich den Einträgen einer Matrix, woher sich auch der Name "`MX"' ableitet.\footzit{Vgl.}{Samet90}{Seite 86}
	\item \textbf{Die Fläche des Raumes ist quadratisch mit einer Zweierpotenz als Seitenlänge.}
		Da der Raum aus praktischen Gründen in 4 gleichgroße Teile partitioniert wird, entsteht eine Gesamtgröße von $2^n$x$2^n$. Bei Datenregionen, welche nicht diese Ausdehnung besitzen, können Leereinträge verwendet werden, um diese Größe zu erreichen.
\end{enumerate}

\myfig{img/mxquadtre-full-origdata-trimmed}{mxquadtree}{width=.7\textwidth}{MX Quadtree}{MX Quadtree. Diese Instanz ist eher spärlich besetzt.}
Abbildung \ref{fig:mxquadtree} auf Seite \pageref{fig:mxquadtree} zeigt dieselben Daten wie in den vorhergegangen Grafiken in Form eines MX Quadtrees.
Dabei fällt auf, dass die Aufteilung des Raumes hier unabhängig von der Reihenfolge des Einfügens der Knoten ist,
was eine Konsequenz aus der Partitionierung auf Basis der Raumstruktur ist.
Dies führt auch zu einer konstanten Höhe $h$ des Baumes ohne Bezug zu den konkret vorhandenen Datenblättern, wodurch wiederum nur die begrenzte Anzahl von Knoten $2^h * 2^h$ in einem MX Quadtree gespeichert werden können.\footzit{Vgl}{Samet90}{Seite 88}
Diese Einschränkung ist jedoch durch die obigen Bedingungen gesichert.

Ein klassischer Anwendungsfall dieses Prinzip sind Rastergrafiken, welche ein geeignetes mentales Modell für MX Quadtrees darstellen, da hier jeder Datenpunkt  (Pixel) offensichtlich genau 1x1 groß ist und einer Koordinate zugeordnet ist.\footzitx{Vgl.}{bb29082}
Davon abgeleitet spricht man in diesem Kontext von weißen, schwarzen und grauen Knoten\footzit{Vgl}{DBLP:journals/cacm/Gargantini82}{Seite 2}:% cp
\label{coloring}
\begin{description}
	\item[Schwarze Knoten] sind entweder Datenblätter oder Knoten mit vier schwarzen Kindern.
	\item[Graue Knoten] stellen Knoten dar, welche mindestens ein graues Kind besitzen oder mindestens je ein schwarzes und ein weißes Kind.
	\item[Weiße Knoten] sind leere Blätter ohne Daten bzw.\ Knoten, die weder direkt noch indirekt mittels Kindverweise auf Daten verweisen. Diese werden im Allgemeinen nicht explizit repräsentiert.
\end{description}

Eine konkrete Instanz eines MX Quadtree enthält somit nur schwarze und graue Knoten.
Das Nicht-Repräsentieren weißer Knoten führt dazu, dass die Struktur des Baumes erst beim Einfügen aufgebaut wird.
Dies ist jedoch nur eine Optimierung; es wäre genauso möglich, den vollständigen Baum mit weißen Knoten bzw.\ Blättern aufzufüllen, welche später grau oder schwarz eingefärbt bzw.\ von schwarzen Blättern ersetzt werden.

Das Löschen von Knoten im MX Quadtree ist weiters trivial, da im Gegensatz zu Point Quadtrees hier die Daten keinen Einfluss auf die Struktur des Baumes haben und nur in Blättern gespeichert werden. Nach dem Entfernen des eigentlichen Datenblattes muss nur die Färbung der Knoten am Pfad von der Wurzel zu diesem Blatt überprüft und gegebenenfalls angepasst werden.

\subsection{PR Quadtree}

Die Einschränkung durch diskrete Koordinaten bei MX Quadtrees ist manchmal in der Praxis nicht tragbar.
Nichtsdestoweniger ist die Eigenschaft, dass dieser Baumtyp nicht entarten kann (da die Einfügereihenfolge keine Rolle spielt), oft sehr sinnvoll. 

Der PR Quadtree stellt eine Möglichkeit dar, diesen Zwiespalt zu Lösen. 
Er ist eine Kombination von Point und Region Quadtree, wovon sich auch der Name ableitet (\textbf{P}oint \textbf{R}egion Quadtree).\footzit{Vgl.}{Samet90}{Seite 92f}
Hier orientiert sich die Aufteilung des Raumes ähnlich den MX Quadtrees wiederum an der rekursiven Dekomposition eines fixen Bereiches, diese kann jedoch beliebig tief werden.

Die Einfügeoperation läuft wie folgt ab:
Der tiefste Quadrant, welcher die Koordinaten eines einzufügenden Knotens beinhaltet, wird gesucht.
Ist dieser leer, kann der Knoten hier platziert werden.
Andernfalls muss eine weitere Unterteilung vorgenommen werden, was durch Partitionierung des Quadranten in gleichgroße Teile geschieht. 
Der Knoten, welcher sich in dem Quadranten befand, wird in die neue Unterteilung überführt, und es wird neuerlich versucht, den einzufügenden Knoten in dieser zu platzieren. 
Sollte es hier erneut zu Konflikten kommen, wird der Prozess der Partitionierung rekursiv so lange wiederholt, bis beide Knoten in verschiedene Quadranten eingeteilt werden.
Dies ist trivialerweise garantiert, wenn die Koordinaten verschieden voneinander sind.
% ref z.b. SametPolygon S 4

Bei diesem Vorgang ist die Dekompositionsstruktur offensichtlich unabhängig von den konkreten Schlüsseln, wodurch die Einfügereihenfolge irrelevant wird und der Baum nicht im Sinne von Point Quadtrees entarten kann.\footzit{Vgl}{Samet90}{Seite 96}.

Diese Strategie kann jedoch problematisch werden, wenn Datenpunkte nahe aneinander liegen.
Hier müssen viele Unterteilungen getroffen werden, bis sie in verschiedene Quadranten eingeteilt werden können. 
Diese Struktur ist somit mit dieser Einschränkung für alle Schlüsseltypen geeignet.\footzit{Vgl}{Samet90}{Seite 95f}

Das Löschen aus einem PR Quadtree ist wiederum unkompliziert, da sich die Daten nur in Blättern befinden.
Durch das Entfernen eines Blattes können Unterteilungen überflüssig werden, wenn etwa ein Knoten nur ein Kind besitzt.
In diesem Fall kann der entsprechende Knoten einfach durch das Kind ersetzt werden.

\newpage
\part{Praktikum}

{\Huge \bf Dieser Abschnitt ist ein work in progress.}
\newpage

\section{Problemstellung}

In dem Praktikum habe ich mich mit einer Problemstellung aus dem Spiel "`Unknown Horizons"' beschäftigt.
Um das Umfeld der Aufgabenstellung deutlich zu machen, werde ich zuerst auf dieses Programm näher eingehen.

\subsection{Unknown Horizons}
"`Unknown Horizons"' ist ein klassisches Aufbaustrategiespiel, in welchem eine Inselgruppe besiedelt wird. 
Das Szenario ist historisch gesehen vergleichbar zur Besiedelung Amerikas durch europäische Siedler.

Ziel des Spieles ist es, eine florierende Wirtschaft aufzubauen, welche die Bevölkerung mit Waren versorgt, die wiederum mit Steuern die laufenden Kosten der Produktionsketten und den Bau neuer Gebäude finanzieren.
Aus Spieler\_innensicht geschieht der Aufbau der Siedlung durch das Errichten von Gebäuden, welche anschließend weitestgehend autonom arbeiten.

Das Programm ist unter der GPL-2\footurl{http://www.gnu.org/licenses/gpl-2.0.html}{01.03.2011} lizenziert und somit freie, offene Software. 
Es befindet sich noch in einer relative frühen Phase der Entwicklung, obschon der bereits implementierte Teil "`spielbar"' ist.
Nähere Informationen sind unter \url{http://www.unknown-horizons.org} verfügbar.

\subsection{Technische Details}

Die Spiellogik ist in Version 2.6 der Sprache Python\footurl{http://www.python.org}{01.03.2011} implementiert und
baut auf die Engine FIFE\footurl{http://fifengine.de}{01.03.2011} auf.
Weiters läuft das Spiel in nur einem Thread ab, weswegen jede Berechnung den Programmablauf blockiert, und somit sehr effizient sein muss.

Die Spielwelt stellt eine zweidimensionale Fläche dar.
Sie ist in 1x1 große Tiles unterteilt, welche daher die kleinste Größeneinheit sind. 
Die Zuordnung von Tiles zu Koordinaten ist bijektiv und über den ganzen Spielverlauf hindurch konstant.
Diese Tiles (dt.: "`Fliesen"') sind in verschiedene geographische Typen unterteilt (unter anderem Wasser, Land, Küste), denen zur graphischen Darstellung ein entsprechendes Bild zugeordnet ist. Desweiteren enthalten sie einen Verweis auf etwaige Gebäude, welche den Platz an dieser Koordinate einnehmen und stellen so die Basis der räumlichen Verwaltung der Inseln dar.

Aus diesem System folgt, dass alle Objekte im Spiel nur ganzzahlige, diskrete Koordinaten aufweisen.


\subsection{Problembeschreibung}
Die Problemstellung, welche in diesem Praktikum behandelt wird, ist eine Bereichsabfrage:

Im Spiel hat jedes Gebäude einen Einflussbereich, innerhalb welchem gewisse Aktionen ausgeführt werden können.
Ein Holzfäller etwa kann nur Bäume fällen, welche sich innerhalb dieses Radius befinden,
eine Schule nur Einwohner dieses Bereiches betreuen.
\myfig{img/uh-boatbuilder-overview}{boatbuilder}{width=.8\textwidth}
{Screenshot aus "`Unknown Horizons"'}
{Screenshot aus "`Unknown Horizons"'. Abbgebildet ist hier ein Bootsbauer inklusive seinem Aktionsradius, welcher den Bereich beschreibt, aus welchem dieser Rohstoffe für den Bootsbau einsammeln kann.}
Abbildung \ref{fig:boatbuilder} auf Seite \pageref{fig:boatbuilder} zeigt ein Gebäude, dessen Einflussbereich eingefärbt wurde.

Dieses Gebiet umfasst alle Tiles, welche folgende Ungleichung erfüllen
\begin{equation}
	Distanz(Gebaeude, Tile) \leq Radius\ des\ Einflussbereichs
\end{equation}
sowie sich
\begin{enumerate}
	\item im Areal der Siedlung 
	\item an markierbaren Stellen
\end{enumerate}
befinden.
Da die Fläche eines Gebäudes eine beliebige rechteckige Form darstellen kann, entsteht durch diese Gleichung ein Rechteck mit abgerundeten Ecken, welches durch Bedingungen 1 und 2 beliebig beschränkt sein kann.

Nachdem dieser Bereich beim Gebäudebau einen zentralen Faktor darstellt, muss er dargestellt werden, wenn die Maus über die Spielwelt bewegt wird, um eine geeignete Position für ein zu bauendes Gebäude zu suchen, was offensichtlicherweise auch sehr schnell geschehen muss, um hier Verzögerungen zu vermeiden.
Die Einfärbungsroutine wird nur dann aufgerufen, wenn der Mauszeiger einen Moment über einer gewissen Koordinate verweilt, um "`Ruckler"' zu vermeiden. Im allgemeinen Anwendungsfall wird anschließend auf die Darstellung des Bereiches gewartet, um sicher zu stellen, dass das Gebäude mit diesem Aktionsradius die gewünschte Funktion übernehmen kann.

%Konkret geschieht die Anzeige des Bereiches durch das einzelne Übergeben aller Tiles des Einflussgebietes an eine Markierungsfunktion der Engine, welche die entsprechenden Objekte als einzufärben vermerkt und dies schließlich beim nächsten Durchlauf des Renderers durchführt.

Die ursprüngliche Implementierung dieser Aufgabe ist für einen flüssigen Spielablauf zu ineffizient, besonders erfahrene Spieler\_innen stoßen hier durch ihr zügiges Spieltempo auf Verzögerungen.
Wie später noch deutlich werden wird, entstehen die Verzögerungen im Wesentlichen durch Berechnung der zu markierenden Tiles, das Übergeben dieser an die Engine sowie das eigentliche Einfärben. 
In dieser Arbeit werde ich mich auf die Optimierung des ersten Teils beschränken, was für zufriedenstellende Laufzeitergebnisse alleine in der Praxis nicht ausreicht.
Die Performance der Engine ist hier weiters schwer messbar, was verschiedene Gründe hat:
Diese ist in einer anderen Programmiersprache als die Spiellogik implementiert, wodurch bei jedem Funktionsaufruf (etwa die Übergabe der einzelnen Tiles) Zeit im Wrapper verbraucht wird, welcher das Interface bereitstellt.
Die Markierungsfunktion erledigt weiters nur einen Teil der Arbeit -- das eigentliche Rendern findet in periodischen Durchläufen statt, in welchen das gesamte Bild berechnet wird.
In diesen Prozess fließen somit viele äußere Faktoren ein. 

\subsection{Ursprünglicher Lösungsansatz}

Die bisherige Methode zur Speicherung der Tiles stellt eine Hashmap dar, in welcher die Koordinaten der Insel als Schlüssel auf die Tileobjekte verweisen. 
Es sei darauf hingewiesen, dass hier Nähebeziehungen nicht repräsentiert werden.

Der Lösungsansatz besteht im Wesentlichen aus drei Schritten:
\begin{enumerate}
	\item Berechnung der Koordinaten im Einflussbereichs.
	\item Lookup dieser Koordinaten in der Hashmap.
	\item Überprüfung der Tiles bezüglich Siedlungszugehörigkeit und Markierbarkeit.
\end{enumerate}

Schritt 1 kann äußerst schnell durchgeführt werden.
Zusammengefasst berechnet der verwendete Algorithmus die Grenze eines Viertels des Bereiches, die restlichen Viertel werden gespiegelt.
Diese Begrenzungen können schließlich einfach zeilenweise aufgefüllt werden.
In dieser Form ist der Ansatz nicht optimal (die Berechnung eines Achtels würde etwa auch \mbox{ausreichen}), in der Praxis ist hingegen der Anteil an der gesamten Laufzeit so gering, dass weitere Optimierungen nicht gerechtfertigt werden könnten.

Der nächste Schritt kann für einzelne Elemente auch sehr schnell umgesetzt werden, bei großen Flächen entsteht hier jedoch durch die Anzahl der Tiles eine messbare Verzögerung.
Es ist nicht möglich, mehrere angrenzende Tiles gleichzeitig anzusprechen, jedes muss einzeln aus der Hashmap abgefragt werden.
Besonders wenn viele Tiles am Meer liegen, wie es etwa in Abbildung \ref{fig:boatbuilder} auf Seite \pageref{fig:boatbuilder} der Fall ist, scheitern alle diese Lookups, denn die Koordinatenberechnung hat keine Informationen über die Struktur der Insel.

Der dritte Schritt ist notwendig, da die Hashmap der Insel für verschiedene andere Anwendungsfälle sämtliche Tiles der Insel beinhalten muss; eine spezielle Hashmap zur Markierung könnte dies vereinfachen.

\section{Implementierung}
Nachdem bei diesem Markierungsproblem die Lage der Tiles zueinander eine entscheidende Rolle spielt, ist es naheliegend, dieses mittels Quadtrees zu lösen.
In einem solchen kann die Struktur der Inseln auf eine Weise abgebildet werden,
welches es der Suche ermöglicht, Gebiete am Meer bzw.\ außerhalb der Siedlung schnell zu ignorieren sowie größere, zusammenhängende Blöcke effizient als innerhalb des Bereiches liegend zu identifizieren.

Der Aufbau und die Wartung des Quadtrees können zwar je nach Typ einen Mehraufwand darstellen, dieser ist jedoch nur beim Spielstart (währenddessen ohnehin mit einer Verzögerung gerechnet wird) bzw.\ seltener beim Bau verschiedener Gebäude, welche den Einflussbereich der Siedlung erweitern, erforderlich.
Insofern ist es hier sinnvoll, diesen Overhead in Kauf zu nehmen, um Verzögerungen während des Baumodus zu vermeiden.

Mit einer schnelleren Laufzeit kann hier vor allem dann gerechnet werden, wenn viele Bereiche bei der Suche ausgeschlossen werden können.
In Abbildung \ref{fig:boatbuilder} auf Seite \pageref{fig:boatbuilder} liegen etwa die Hälfte der Tiles im Einflussgebiet des Gebäudes am Meer und sind somit im Quadtree nicht vorhanden.
Bei einer günstigen Partitionierung des Raumes ist somit zu erwarten, dass auf relativ hoher Ebene gewisse Kinder von Knoten, welche diesen Bereich abdecken, in der Terminologie von Abschnitt \ref{coloring} "`weiß"' und somit durch \mynull\ repräsentiert sind, wodurch der Suchalgorithmus die Information bekommt, dass dieses gesamte Gebiet nicht weiter berücksichtigt werden muss.
In der ursprünglichen Implementierung ist diese Information nicht vorhanden, wodurch jede Koordinate in dieses Bereichs in der Hashmap unnötigerweise abfragt wird.

Da die Unterteilung des Raumes in Quadraten vorgenommen wird und der Einflussbereich der Gebäude ein Rechteck mit abgerundeten Ecken ist, 
muss der Algorithmus an den Rändern bis zur Blattebene absteigen, um die genaue Grenze zu bestimmen.

\subsection{Wahl des Quadtreetyp}

Die Art der im Quadtree zu speichernden Daten sind ausschließlich 1x1 große Tiles. Da man diese ebenso als Punkte interpretieren kann, eignen sich für diese Anwendung punktbasierte sowie bereichsbasierte Quadtreetypen gleichermaßen.

Weiters liegt hier eine fixe Raumaufteilung vor:
Siedlungen sind durch die Insel begrenzt und wachsen im Allgemeinen auf diese Größe.
Dies bedeutet, dass im Falle von punktbasierten Quadtrees, welche an sich entarten können, optimierte Bäume berechnet werden können, um diesem Problem zu entgegnen.
Dadurch würde die Struktur dieser jener der bereichsbasierten Varianten ähneln, da alle Koordinaten innerhalb einer Inseln im Quadtree repräsentiert werden müssen, und die effizienteste Möglichkeit, dies zu tun, ist eine Aufteilung eines Bereiches genau in der Mitte, was exakt der Strategie des MX Quadtrees entspricht.

Aus diesen Gründen, sowie der Einfachheit des Löschens, habe ich mich dazu entschieden, die gestellte Aufgabe mit einem MX Quadtree zu lösen.
Es ist jedoch anzumerken, dass im Prinzip jeder der hier vorgestellten Typen für diese Problemstellung verwendet werden kann.

\clearpage

\begin{lstlisting}[float,caption=Python-ähnlicher Pseudocode zur Lösung des Markierungsproblems]
"""
Klasse der Knoten des MX Quadtrees
"""
class Node(object):

	[...]

	"""
	Rekursive Methode der Klasse Node, welche einen Callback auf alle Blaetter anwendet, die innerhalb der Bereichsspezifikation "area" liegen.
	"""
	def visit_radius_tiles(self, area, callback)
		if self.is_leaf():
			# Auf Blattebene muss nur ueberprueft werden, ob der Callback auf den aktuellen Knoten angewendet werden soll
			if area.includes(self):
				callback(self)
		else:
			quadrants = self.get_overlapping_quadrants(area)
			for quadrant in quadrants:
				# Optimierung: Sollte der ganze Quadrant im Bereich liegen, muessen die einzelnen Subknoten nicht mehr einzeln ueberprueft werden.
				if self.check_full_quadrant_included(quadrant, area):
					quadrant.visit_all_tiles(callback)
				else:
					quadrant.visit_radius_tiles(area, callback)
\end{lstlisting}

\section{Analyse}

\section{Conclusio}

\newpage

\listoffigures

Alle in dieser Arbeit verwendeten Bilder wurden vom Autor erstellt.

\lstlistoflistings

\newpage

\nocite{*} % display all entries of bib-file
\bibliography{bib}

\end{document}
