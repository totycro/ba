\documentclass[%
			%fontsize=11pt,%
			paper=a4,% 
			%DIV12, % mehr text pro seite als defaultyyp
			DIV12,
			%DIV=calc,%
			%twoside=false,%
			liststotoc,
			bibtotoc,
			draft=false,% final|draft % draft ist platzsparender (kein code, bilder..)
			titlepage
			]{scrartcl}


\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

% for color-highlighted code
\usepackage[usenames]{color} % for grey comments
%\usepackage{alltt}

\usepackage[doublespacing]{setspace}
\usepackage{tabularx}
\usepackage{comment}
\usepackage[final]{listings} % sourcecode in document
\usepackage{url}      % for urls
\usepackage{multicol}
\usepackage{caption}
\usepackage{enumerate}

\usepackage{graphicx}

%\usepackage[square]{natbib} % \cite ; square|round etc.
\usepackage[numbers,square]{natbib}
%\usepackage[numbers,round]{natbib}

%\usepackage{bibgerm}
%\bibliographystyle{plain}
%\bibliographystyle{alpha}
\bibliographystyle{alphadin}
%\bibliographystyle{dinat}
%\bibliographystyle{plainnat}

%\bibdata{bib.bib}

\newcommand{\zit}[3]{#1 \cite{#2}, #3}
\newcommand{\zitx}[2]{#1 \cite{#2}}
\newcommand{\footzit}[3]{\footnote{\zit{#1}{#2}{#3}}}
\newcommand{\footzitx}[2]{\footnote{\zitx{#1}{#2}}}

\newcommand{\inlinecode}[1]{\mbox{\texttt{#1}}}

\newcommand{\mynull}{\textit{NULL}}
%\newcommand{\mynull}{\textbf{nil}}

\newcommand{\kd}{\mbox{\textit{k}-d}}

% smaller url style
\makeatletter
\def\url@leostyle{%
\@ifundefined{selectfont}{\def\UrlFont{\sf}}{\def\UrlFont{\small\ttfamily}}}
\makeatother
\urlstyle{leo}

\newcommand{\myfig}[5] {
 \begin{figure}[tbph]
	 \centering
	 \includegraphics[#3]{#1}
	 \caption[#4]{#5}
	 \label{fig:#2}
 \end{figure}
}

\title{Quadtrees}
\author{Bernhard Mallinger \\ e0707663}
%\subtitle{}
%\date{13. November 2007}
\publishers{Betreut durch Univ.-Ass. Dipl.-Ing., BSc Christian Schauer}

%\usepackage{fancyhdr}
%\setlength{\headrulewidth}{0.0pt}
\pagestyle{plain}

\definecolor{grey}{gray}{.2} % for grey commnts
\lstset{language=sh,%
escapeinside={@}{@},
extendedchars=true,%
%inputencoding=utf8x,%
basicstyle=\ttfamily\small,%
commentstyle=\color{grey},%
keywordstyle=,% no bold tt in standard font
captionpos=b,
tabsize=2,
showstringspaces=false,
breaklines=true,
backgroundcolor=\color{lgray}
}

% just for screen-display!
%\usepackage{newcent}

\begin{document}

\maketitle

\tableofcontents 

\newpage

%%%%
% TODO
%
% Einleitung mit erklärung:
% k
% n
% schlüssel
% mehrdimensionale daten (bisschen wie kdtree.pdf)
%
% schlüssel unique -- überlauflisten
%
% binäre suche im anfang reinbringen -- bin tree
%
% point qt: suche: range + neighborhood 
%
% anwendungen (vllt extrakapitel) (kriterien für anwendbarkeit)
%
% graphendarstellung? (wort)
%
% seite 3 (aus paper zitieren)
%
% v.a.: http://www.springerlink.com/content/x7147683u3241843/
% u.a.: http://www.springerlink.com/content/v171j240584691x5/
% (für pseudo) http://www.springerlink.com/content/k4k475357h707034/
% ^ techreport? verfügbar
%
% bild für entartung
%
% bild pr tree 


\part{Theorie}
\section{Einführung}
Quadtrees stellen eine Datenstruktur dar, welche von Binärbäumen abgeleitet sind. Sie erweitern dessen Prinzip der rekursiven, hierarchischen Aufteilung eines Raumes auf mehrere Dimensionen. 
Im Allgemeinen beschränkt man sich hier zur Vereinfachung auf zweidimensionale Daten, wobei die Verallgemeinerung auf \textit{k}-dimensionale Daten trivial ist.

Anstatt wie bei Binärbäumen den Raum bei jedem Schritt in zwei Unterbäume zu teilen, werden bei Quadtrees vier Kinder verwendet, um alle möglichen Richtungen in zwei Dimensionen bezüglich des aktuellen Knoten abzudecken. Der Name "`Quadtree"' leitet sich hiervon ab (lat. "`quadri-"': "`vier-"'). 
Analog dazu bezeichnet man 3-dimensionale Bäume als "`Octtrees"'. Es ist weiters einfach zu sehen, dass $k$-dimensionale Bäume $2^k$ Kinder pro Knoten aufweisen.\footzit{Vgl.}{Bentley:1979}{Seite 16}

Räumliche Strukturen wie Quadtrees sind generall dann sinnvoll, wenn die Entfernung zweier Punkte für die Anwendung relevant ist. Beispiele hierfür sind unter anderem Repräsentation von Bildern (angrenzende Bereiche besitzen oftmals ähnliche Farben) oder Kollisionserkennung, wo das Interesse sogar auf sich überschneidende Strukturen liegt.

Beim Zugriff auf die so in einem Quadtree gespeicherten Daten unterscheidet man zwischen verschiedenen Anfragetypen:\footnote{Basierend auf \cite{Knuth:1998:ACP:280635}, Seite 559 und der Erweiterung durch \cite{Bentley:1975:nearest}}
\begin{description}
	\item[Point Query.] Mit dieser Anfrage versucht man herauszufinden, welche Daten sich bei einem bestimmten Punkt befinden. Anworten auf diese Anfrage können entweder \mynull\ bzw.\ ein Datenobjekt sein.
	\item[Range Query.] Hier interessiert man sich für die Knoten, welche innerhalb von Bereichen, die hinsichtlich mehreren Dimensionen ausgedehnt sein können, liegen. Zurückgegeben wird eine möglicherweise leere Liste von Datenobjekten.
	\item[Neighborhood Query.] Dieser Anfragetyp fokussiert sich auf Nähebeziehungen. Konkret werden die Knoten gesucht, welche die geringste Entfernung zu einem bestimmten Knoten aufweisen. Der Rückgabewert kann hier eine Liste oder ein einzelnes Datenobjekt sein.
\end{description}


\subsection{Funktionsprinzip}

Wie eingangs erwähnt wird bei einem Quadtree der Raum in einem Schritt in zwei Dimensionen geteilt.
In diesem Kontext bezeichnet man die Abschnitte der Unterteilung als "`Quadranten"'.
Dies kann, wie Abbildung \ref{fig:quadtree} auf Seite \pageref{fig:quadtree} demonstriert, direkt an den Koordinaten der Knoten stattfinden, je nach Quadtreetyp werden hier jedoch verschiedene Strategien eingesetzt.

Die einzelnen Knoten eines Baumes beinhalten Verweise auf vier Kindstrukturen, welche diejenigen Daten beinhalten, die sich vollständig in der entsprechenden Richtung des Knotens befinden. 
Gleichzeitig sind alle Knoten bei einem großen Teil der Quadtreetypen zugleich auch Datenknoten und enthalten somit die zu speichernden Werte.
Die Koordinaten der zu speichernden Daten bestimmen demnach die Gestalt der Struktur.

Dieses Prinzip der rekursiven Dekomposition erlaubt das effiziente Suchen in logarithmischer Zeit.\footnote{Siehe Kapitel \ref{sec:pointquadtree-suche} auf Seite \pageref{sec:pointquadtree-suche}}
\myfig{img/quadtree}{quadtree}{width=.4\textwidth}{Funktionsprinzip eines Quadtrees}{Alle Kinder repräsentieren Teilbäume, welche sich vollständig in NW-, NE-, \mbox{SW-} oder SE-Richtung des aktuellen Knoten befinden. Je nach Konvention können die Quadranten auch mittels ihrer Nummerierung referentiert werden.}

\section{Punktbasierte Quadtrees}
\label{sec:pointbased}
\subsection{Point Quadtree}
Dieser Quadtreetyp wurde erstmals 1974 von Finkel und Bentley in \cite{DBLP:journals/acta/FinkelB74} eingeführt.\footzit{Vgl.}{compgeom:2000}{Seite 318}
Point Quadtrees kann man als direkte Verallgemeinerung von binären Suchbäumen auf mehrdimensionale Räume auffassen. 
%\footnote{\zit{Vgl.}{Samet90}{Seite 48}}
Ähnlich zu diesen erfolgt die Aufteilung direkt an den Koordinaten der Knoten, sowie an beiden Dimensionen gleichzeitig. 

% vllt deBerg S 316 tiefe O( (d+1) n )
% und S 322
% As we have seen in this chapter, the size and depth of a quadtree for a set of n points cannot be bounded in terms of the number of the number of points only.

Abbildung \ref{fig:pointquadtree} auf Seite \pageref{fig:pointquadtree} zeigt eine Instanz eines Point Quadtrees in zwei üblichen Darstellungsvarianten: Baum- und Graphendarstellung.
In der Ersteren wird nur die Struktur des Baumes betrachtet, die Lage der Datenknoten ist ausschließlich relativ zueinander sichtbar.
Die Zweitere konzentriert sich mehr auf die absolute Position der Punkte in einem Koordinatensystem und zeigt zusätzlich dazu die rekursive Dekompositionsstruktur ein.
Die Bezeichnung der Knoten in der Grafik gibt die Reihenfolge der Einfügung an. Bereits hier wird deutlich, dass die Form des Baumes durch diese Reihenfolge determiniert wird.\footnote{Vgl. Kapitel \ref{sec:pointquadtree:insert} auf Seite \pageref{sec:pointquadtree:insert}}
\myfig{img/pointquadtree-ins7+tree-trimmed}{pointquadtree}{width=.9\textwidth}{Point Quadtreee}{Gegenüberstellung: Ein Point Quadtree in Baum- bzw.\ Graphendarstellung}

\subsubsection{Suche}
\label{sec:pointquadtree-suche}
Der Algorithmus zur Suche von Koordinaten (Point Query) ergibt sich unmittelbar aus dem rekursiven Aufbauprinzip des Quadtrees. 

Die Suche beginnt beginnt an der Wurzel. In jedem Schritt werden je ein Vergleich der $x$- und $y$-Koordinate des aktuellen Knotens mit dem gesuchten Knoten durchgeführt, wodurch der Quadrant bestimmt wird, in welchen sich der gesuchte Knoten befindet. Ist dieser Quadrant leer, d.h.\ ist kein Kindknoten bezüglich dieser Richtung am aktuellen Knoten vorhanden, wird die Suche erfolglos abgebrochen; andernfalls wird sie bei diesem Kindnoten fortgesetzt, bis die Koordinaten des gesuchten Knoten mit jenen des aktuellen Knoten übereinstimmen.

Durch die rekursive Aufteilung kann hier im Average Case mit logarithmischer Laufzeit gerechnet werden ($O(log_4\ N)$).
Allerdings hängt diese Größe von der Balanzierung des Baumes ab, wofür es beim Point Quadtree keine Garantien gibt. Dies führt im Falle einer Entartung zu einer linearen Laufzeit ($O(n)$).\footzit{Vgl.}{Samet90}{Seite 52}

%Weiters kann gezeigt werden, dass Range Queries in $O(n\ log_k\ n)$ abgearbeitet werden können.\footzit{Vgl.}{Lueker78}{Seite 1}

\subsubsection{Einfügen}
\label{sec:pointquadtree:insert}
Das Verfahren zum Einfügen neuer Daten baut direkt auf die Suche auf.
In dem Quadranten, in welchem eine normale Suche abbrechen würde, wird das Datum eingefügt, indem an der entsprechenden Stelle, die sich offensichtlicher Weise in diesem Quadranten befinden muss, der Datenknoten platziert wird.
Der asymptotische Aufwand dieser Operation ist trivialerweise identisch mit jenem der Suche.

Der neue eingefügte Knoten teilt den Raum wiederum an seinen $x$- bzw. $y$-Koordinaten und erweitert so die Struktur des Baumes.  
Es ist schnell ersichtlich, dass hier, genau wie bei einem Binärbaum, Entartungen auftreten können, da sich die Struktur dynamisch mit jedem eingefügten Element herausbildet. 
% umformulieren:
Ein besonders Problem stellen hier etwa geordnete Daten da. Werden diese in der gegebenen Reihenfolge eingefügt, degeneriert der Baum zu einer linearen Listen. Sind andererseits beim Aufbau des Baumes bereits alle Daten verfügbar, kann durch folgende Strategie ein optimale Balanzierung erreicht werden: Der Median der sortierten Liste von Daten wird als Wurzel verwendet, die restlichen Elemente werden in 4 Gruppen eingeteilt, welche den Quadranten dieser Wurzel zugeordnet werden. Auf jede dieser Unterteilungen wird der Prozess rekursiv angewendet.\footzit{Vgl.}{Samet90}{Seite 52f}
% bild entartung?

\subsubsection{Löschen}
\label{sec:pointquadtree:delete}
Das Entfernen eines Knotens aus einem Quadtree ist im Allgemeinen eine komplexe Operation, da die Knoten alleine die Struktur des Baumes bilden, und diese auch nach dem Löschen weiterhin gewisse Eigenschaften innehaben muss.
Bei Binärbäumen stellt dies kein allzu großes Problem dar, da in einem eindimensionalen Raum immer ein geeigneter Ersatz in Form des nähesten Knotens für einen zu entfernenden Knoten zur Verfügung steht.\footzit{Vgl.}{DBLP:journals/cacm/Samet80a}{Seite 2}
Im Fall von Quadtrees muss eine Substitution hingegen Bedingungen hinsichtlich zweier Dimensionen genügen, wodurch es ein Näheverhältnis wie im eindimensionalen Fall nicht gibt.\footnote{Vgl. Ebenda}
Hier ist ein ein Ersatz nur dann möglich, wenn ein Blattknoten existiert, für den sich im Bereich zwischen den Achsen, welche durch die Koordinaten des Blattknoten bzw.\ deren des zu entfernenden Knoten verlaufen, kein anderer Knoten befindet.\footzit{Vgl.}{DBLP:journals/cacm/Samet80a}{Seite 3}

Ursprünglich wurde vorgeschlagen, alle Kinder des zu entfernenden Knoten neu einzufügen, was einen sehr teuren Prozess darstellen kann.\footzitx{Vgl.}{DBLP:journals/acta/FinkelB74}.
Sollte kein Knoten das oben genannte Kriterium erfüllen, kann nur durch günstige Wahl des Ersatzknotens die Anzahl der neu einzufügenden Knoten minimiert werden, wie etwa in \cite{DBLP:journals/cacm/Samet80a} gezeigt wird.

Eine weitere Optimierung kann dadurch erreicht werden, dass gelöschte Knoten nicht aus dem Baum entfernt, sondern nur als gelöscht markiert werden, um so die Struktur zu erhalten.
Die markierten Knoten dürfen bei zukünftigen Suchen nicht mehr zurückgegeben werden.
Nach jeder Entfernung erhöht sich hierdurch der Anteil der "`toten"' Knoten, was sich negativ auf die Performance aller Operationen auswirkt, und periodische Restrukturierungsmaßnahmen des Baumes erfordert.
Durch dieses Verfahren kann folglich der Aufwand einzelner Löschoperationen abgefedert werden, auf Kosten von regelmäßigen Wartungskosten.

\subsection{Pseudo Quadtree}
\label{sec:pseudoquadtree}
Der Pseudo Quadtree ist eine Abwandlung des Point Quadtrees, welche Löschen in logarithmischer Zeit sowie einfachere Rebalanzierung bei Deformation ermöglicht. Diese Form des Quadtrees wurde 1982 von Overmars und van Leeuwen in \cite{DBLP:journals/acta/OvermarsL82} entwickelt.

Dem Pseudo Quadtree liegt die Analyse zu Grunde, dass die Probleme beim Entfernen von Knoten und bei der Balanzierung bei Point Quadtrees daher stammen, dass die Datenpunkte selbst die Struktur des Baumes bilden, und so nur äußerst wenig Flexibilität vorhanden ist.
Aus diesem Grund wurde unterscheidet sich der Pseudo Quadtree davon insofern, als dass die Dekomposition des Raum an beliebigen Punkten stattfinden kann. 

Konkret funktioniert das Einfügen beim Pseudo Quadtree wie folgt:
Der Quadrant eines Datenpunktes wird gesucht.
Ist dieser leer, wird der Knoten hier eingefügt, ohne den Raum an dessen Koordinaten weiter zu unterteilen.
Befindet sich hier hingegen bereits ein anderer Knoten, muss eine neue Untergliederung eingeführt werden.
Hier können beliebige Strategien verwendet werden, um einen Teilungspunkt zu bestimmen, wodurch ein der Anwendung angepasster, gut balanzierter Baum entstehen kann.

Abbildung \ref{fig:pseudoquadtree} auf Seite \pageref{fig:pseudoquadtree} zeigt einen Pseudo Quadtree, welcher dieselben Daten wie der Point Quadtree in Abbildung \ref{fig:pointquadtree} auf Seite \pageref{fig:pointquadtree} beinhaltet.
In diesem Fall wurde der Mittelpunkt von zwei Knoten als Punkt zur Teilung verwendet.
\myfig{img/pseudoquadtree-ins3-trimmed}{pseudoquadtree}{width=.6\textwidth}{Pseudo Quadtree}{Pseudo Quadtree}

Sollte trotz einer angepassten Strategie ein Ungleichgewicht entstehen, kann der Subbaum, dessen Wurzel der höchste Knoten ist, bei welchem eine unbalanzierte Verteilung seiner Kindknoten festgestellt wird, neu strukturiert werden, indem eine neue Aufteilung der vorhandenen Knoten berechnet wird.\footzit{Vgl.}{DBLP:journals/acta/OvermarsL82}{Seite 5} % cp
Es kann gezeigt werden, dass im allgemeinen Fall eine Teilung möglich ist, in der sich in jedem der 4 Quadranten höchstens ein Drittel der Knoten befinden.\footzit{Vgl.}{DBLP:journals/acta/OvermarsL82}{Seite 7} % cp

Durch diese Aufteilung des Raumes an beliebigen Punkten befinden sich Daten schließlich nur noch an den Blättern. Dies wiederum ist der optimale Fall bezüglich dem Entfernen von Knoten -- ein Knoten ohne Kinder kann jederzeit ohne zusätzlichen Aufwand gelöscht werden. Da das Entfernen eines Knotens immer auch das Suchen desselben erfordert, entsteht somit ein logarithmischer Aufwand.

%\ref{sec:pointquadtree:delete} \pageref{sec:pointquadtree:delete}

\subsection{\kd\ Tree}
Diese Variante wurde von Bentley kurz nach dem Point Quadtree 1974 in \cite{Bentley:1975} entwickelt. Der Name \kd\ deutet an, dass dieser Baum $k$-dimensionale Schlüssel verwendet. 

Der \kd\ Tree kann wie der Point Quadtree als Verallgemeinerung des Binärbaums gesehen werden, hier wird hingegen ein etwas anderer Ansatz verfolgt:
Anstatt den Raum gleichzeitig in allen Dimensionen zu partitionieren und somit die Notwendigkeit von $2^k$ Kindern pro Knoten zu erfordern, wird in jedem Schritt nur eine Dimension berücksichtigt und so eine binäre Unterteilung von eigentlich mehrdimensionalen Schlüsseln ermöglicht.
Diese Mehrdimensionalität wird bei \kd\ Trees weiters dadurch ausgedrückt, dass die Dimensionen, bezüglich derer an einer gewissen Tiefe geteilt wird, beliebig alterniert.
Im zweidimensionalen Fall könnte hier etwa bei geraden Tiefenebenen an der $x$-Achse bzw bei ungeraden an der $y$-Achse geteilt werden, wie etwa Abbildung \ref{fig:kdtree} auf Seite \pageref{fig:kdtree} zeigt.
Ursprünglich wurde genau dieses Abwechslungsmuster vorgeschlagen,\footzit{Vgl.}{Bentley:1975}{Seite 2}
wobei dieses auch dynamisch beliebig gewählt und so an die Daten angepasst werden kann\footzit{Vgl.}{Samet90}{Seite 66}.
Verwendet man hier einen dynamischen Ansatz, muss jedoch bei jedem Knoten der Diskriminator mitgespeichert werden.

\myfig{img/kdtree-tree-full-trimmed}{kdtree}{width=.78\textwidth}{\kd\ Tree}{Ein \kd\ Tree: Die Beschriftung links der Unterteilungen gibt die Achse an, bezüglich welcher die Knoten aufgeteilt werden.
\\ \\
Bezüglich den vorhergegangenen Abbildung wurden hier die Koordinaten der Knoten leicht verändert, da in diesem Fall ein äußerst schlecht balanzierter \kd\ Tree entstehen würde, was der Autor aus Demonstrationszwecken vermeiden möchte.}

Dieser Typ bietet gegenüber einem Point Quadtree Vorteile bezüglich des Platzbedarfs:
anstatt $2^k$ sind hier nur 2 Kinder pro Knoten erforderlich. Dies löst das Problem von vielen unnötigen Leereinträgen, welche bei einem Point Quadtree bei einer großen Dimensionsanzahl auftreten können.

Die Operationen Suche und Einfügen ergeben sich direkt aus dem Funktionsprinzip des \kd\ Trees, beide benötigen offensichtlich eine logarithmische Laufzeit im Average Case\footzit{Vgl.}{Bentley:1975}{Seite 1} (sofern der Baum nicht entartet).
Schwieriger ist hingegen das Löschen:
Nach dem Entfernen eines Knotens darf die Struktur des \kd\ Trees nicht verletzt werden, weshalb ein geeigneter Ersatz gefunden werden muss.
Für dieses Problem wurde eine Strategie entwickelt, welche auf der Lösung des analogen Problems bei Binärbäumen basiert und zugleich die Mehrdimensionalität im \kd\ Tree berücksichtigt.\footzit{Für eine detaillierte Beschreibung dieses Verfahrens siehe}{Bentley:1975}{Seite 7} 
Anstatt im Worst Case (bei Löschung der Wurzel) $n$ Neueinfügungen mit dem naiven Ansatz benötigt diese Methode nur $O(n^{1-\frac{1}{k}})$.

Um diesem Problem gänzlich zu entgehen kann ähnlich dem Pseudo Quadtree\footnote{Siehe Kapitel \ref{sec:pseudoquadtree}} auch ein Pseudo \kd\ Tree\footzitx{Vgl.}{DBLP:journals/acta/OvermarsL82} verwendet werden,
in welchem analog zum Pseudo Quadtree die Unterteilung des Raumes nicht an den Koordinaten der Knoten, sondern an beliebigen Punkten vorgenommen wird, und so Daten nur in Blättern gespeichert werden.


% nicht paralellisiert suchen (quelle?)

\section{Bereichsbasierte Quadtrees}
%\subsection{Region Quadtree}

Wie im Kapitel \ref{sec:pointbased} ausführlich erläutert wurde, erfolgt die räumliche Dekomposition bei punktbasierten Quadtrees immer anhand der gegebenen Punkte.\footnote{Bei Point bzw.\ \kd\ Trees gilt dies direkt; bei Pseudo Quadtrees hingegen besteht die Abhängigkeit vielmehr indirekt: die Aufteilung stellt eine Funktion der Punkte dar.}
Dieses Kapitel beschäftigt sich mit Quadtrees, deren Form vordergründig a priori durch die Struktur des Raumes determiniert wird, was in etwa mit dem Prinzip von Tries vergleichbar ist.\footzit{Vgl.}{Samet90}{Seite 85}

Weiters wird in diesem Abschnitt nur insofern auf die verschiedenen Operationen eingegangen, als sie sich von punktbasierten Quadtrees unterscheiden.

\subsection{MX Quadtree}
Der MX Quadtree zeichnet durch seine Art der Raumunterteilung aus:
Der Bereich, in dem die Datenpunkte liegen, wird unabhängig von den konkreten Daten unterteilt,
und zwar rekursiv in vier gleichgroße Quadranten, 
bis auf der untersten Ebene 1x1 große Felder erreicht werden, welche die Daten beinhalten.\footzit{Vgl.}{Samet:1985:SCP:282957.282966}{Seite 1f}

Diese Art der Dekomposition setzt folgendes vorraus:
\renewcommand{\labelenumi}{({\theenumi})}
\begin{enumerate}
	\item \textbf{Konstanter Bereich.}
		Die Region, in welcher sich Daten befinden, muss a priori bekannt sein und während des gesamten Programmablaufs konstant bleiben.
	\item \textbf{Diskrete Koordinaten.}
		Die Schlüssel dürfen nur diskrete Werte annehmen, ähnlich den Einträgen einer Matrix, woher sich auch der Name "`MX"' ableitet.\footzit{Vgl.}{Samet90}{Seite 86}
	\item \textbf{Fläche des Raumes beträgt $2^n$ x $2^n$.}
		Da der Raum aus praktischen Gründen in 4 gleichgroße Teile partitioniert wird, entsteht eine diese Gesamtgröße. Bei Datenregionen, welche nicht diese Ausdehnung besitzen, können Leereinträge verwendet werden, um diese Größe zu erreichen.
\end{enumerate}

\myfig{img/mxquadtre-full-origdata-trimmed}{mxquadtree}{width=.7\textwidth}{MX Quadtree}{MX Quadtree. Diese Instanz ist eher spärlich besetzt.}
Abbildung \ref{fig:mxquadtree} auf Seite \pageref{fig:mxquadtree} zeigt dieselben Daten wie in den vorhergegangen Grafiken in Form eines MX Quadtrees.
Dabei fällt auf, dass die Aufteilung des Raumes hier unabhängig von der Reihenfolge des Einfügens der Knoten ist,
was eine Konsequenz aus der Partitionierung auf Basis der Raumstruktur ist.
Dies führt auch zu einer konstanten Höhe $h$ des Baumes ohne Bezug zu den konkret vorhandenen Datenblättern, wodurch wiederum nur die begrenzte Anzahl von Knoten $2^h * 2^h$ in einem MX Quadtree gespeichert werden können.
Diese Einschränkung ist jedoch durch die obigen Bedingungen gesichert.

Ein klassischer Anwendungsfall dieses Prinzip sind Rastergrafiken, welche ein geeignetes mentales Modell für MX Quadtrees darstellen, da hier jeder Datenpunkt  (Pixel) offensichtlich genau 1x1 groß ist und einer Koordinate zugeordnet ist.\footzitx{Vgl.}{bb29082}
Davon abgeleitet spricht man in diesem Kontext von weißen, schwarzen und grauen Knoten\footzit{Vgl}{DBLP:journals/cacm/Gargantini82}{Seite 2}:% cp
\begin{description}
	\item[Schwarze Knoten] sind entweder Datenblätter oder Knoten mit vier schwarzen Kindern.
	\item[Graue Knoten] stellen Knoten dar, welche mindestens ein graues Kind besitzen oder mindestens je ein schwarzes und ein weißes Kind.
	\item[Weiße Knoten] sind leere Blätter ohne Daten bzw.\ Knoten, die weder direkt noch indirekt mittels Kindverweise auf Daten verweisen. Diese werden im Allgemeinen nicht explizit repräsentiert.
\end{description}

Ein konkreter MX Quadtree enthält somit nur schwarze und graue Knoten.
Das Nicht-repräsentieren weißer Knoten führt dazu, dass die Struktur des Baumes erst beim Einfügen aufgebaut wird.
Dies ist jedoch nur eine Optimierung; es wäre genauso möglich, den vollständigen Baum mit weißen Knoten bzw.\ Blättern aufzufüllen, welche später grau oder schwarz eingefärbt bzw.\ von schwarzen Blättern ersetzt werden.

Das Löschen von Knoten im MX Quadtree ist weiters trivial, da im Gegensatz zu Point Quadtrees hier die Daten keinen Einfluss auf die Struktur des Baumes haben und nur in Blättern gespeichert werden. Nach dem Entfernen des eigentlichen Datenblattes muss nur die Färbung der Knoten am Pfad von der Wurzel zu diesem Blatt überprüft und gegebenenfalls angepasst werden.

\subsection{PR Quadtree}

Die Einschränkung durch diskrete Koordinaten bei MX Quadtrees ist manchmal in der Praxis nicht tragbar.
Nichtsdestoweniger ist die Eigenschaft, dass dieser Baumtyp nicht entarten kann (da die Einfügereihenfolge keine Rolle spielt), oft sehr sinnvoll. 

Der PR Quadtree stellt eine Möglichkeit dar, dieses Problem zu Lösen. 
Er ist eine Kombination von Point und Region Quadtree, daher auch der Name.
Hier orientiert sich die Aufteilung des Raumes ähnlich zu MX Quadtrees wiederum an der rekursiven Dekomposition eines fixen Bereiches, dieser kann jedoch beliebig werden.

Die Einfügeoperation läuft wie folgt ab:
Der tiefste Quadrant, welcher die Koordinaten eines einzufügenden Knotens beinhaltet, wird gesucht.
Ist dieser leer, kann der Knoten hier platziert werden.
Andernfalls muss eine weitere Unterteilung vorgenommen werden, was durch Partitionierung des Quadranten in gleichgroße Teile geschieht. 
Der Knoten, welcher sich in dem Quadranten befand, wird in die neue Unterteilung überführt, und es wird neuerlich versucht, den einzufügenden Knoten in diese zu integrieren. 
Sollte es hier erneut zu Konflikten kommen, wird der Prozess der Partitionierung rekursiv so lange wiederholt, bis beide Knoten in verschiedene Quadranten eingeteilt werden.
Dies ist trivialerweise garantiert, wenn die Koordinaten verschieden voneinander sind.
% ref z.b. SametPolygon S 4

Bei diesem Vorgang ist die Dekompositionsstruktur offensichtlich unabhängig von den konkreten Schlüsseln, wodurch die Einfügereihenfolge irrelevant wird und der Baum nicht im Sinne von Point Quadtrees entarten kann.\footzit{Vgl}{Samet90}{Seite 96}.

Diese Strategie kann jedoch problematisch werden, wenn Datenpunkte nahe aneinander liegen. In diesem Fall müssen viele Unterteilungen getroffen werden, bis sie in verschiedene Quadranten eingeteilt werden können. 
Diese Struktur ist somit mit dieser Einschränkung für alle Schlüsseltypen geeignet.\footzit{Vgl}{Samet90}{Seite 95f}

Das Löschen aus einem PR Quadtree ist wiederum unkompliziert, da sich die Daten nur in Blättern befinden.
Durch das Entfernen eines Blattes können Unterteilungen überflüssig werden, wenn etwa ein Knoten nur ein Kind besitzt.
In diesem Fall kann der entsprechende Knoten einfach durch das Kind ersetzt werden.

\part{Praxis}

\section{Praktikum}

\subsection{Problemstellung}

\subsection{Implementierung}

\subsection{Analyse}

\subsection{Conclusio}

\newpage

\listoffigures

Alle in dieser Arbeit verwendeten Bilder wurden vom Autor erstellt.

\newpage

\nocite{*} % display all entries of bib-file
\bibliography{bib}

\end{document}
